\pdfoutput=1
\documentclass{article}
\usepackage{fullpage}
\usepackage{amsmath, amssymb, amsthm}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[numbers]{natbib}
\usepackage{csquotes}
\usepackage{url}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{algorithmicx}
\setlength{\parskip}{0.5em}
\setlength{\parindent}{0pt}
\theoremstyle{plain}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{example}{Example}
\usepackage{graphicx}
\usepackage{multicol}

\title{An Efficient Deterministic Primality Test}
\author{Joseph M. Shunia}
\date{December 2023}

\begin{document}

\maketitle
\begin{center}
    [Draft]
\end{center}

\begin{abstract}
A deterministic primality test with a polynomial time complexity of $\tilde{O}(\log^3(n))$ is presented. The test posits that an integer $n$ satisfying the conditions of the main theorem is prime. Combining elements of number theory and combinatorics, the proof operates on the basis of simultaneous modular congruences relating to binomial transforms of powers of two.
\end{abstract}

\section{Introduction}

Primality testing has seen remarkable advancements over the past few decades. A significant breakthrough in this field was the AKS primality test, introduced by Agrawal, Kayal, and Saxena (2002) \cite{aks2002}. The AKS test was the first to offer determinism and polynomial-time complexity, a monumental achievement that resolved a longstanding open question in computational number theory \cite{goldreich2008}. However, despite its theoretical importance, the AKS test has practical limitations due to its relatively high polynomial time complexity, rendering it inefficient for most applications. Agrawal, Kayal, and Saxena gave a time complexity of $\tilde{O}(\log^{12}(n))$ for the AKS test \cite{aks2002}. This bound was lowered significantly by Lenstra and Pomerance (2011) to $\tilde{O}(\log^6(n))$ \cite{lenstra2011}. Despite this reduction, AKS remains impractical and is mostly unused.

In the field of cryptography, the unique properties of prime numbers are widely exploited to create cryptographic primitives. It is often the case that many large primes must be generated in rapid succession \cite{lenstra1987}. To make these cryptographic operations practical, fast probabilistic primality tests such as the Baille-PSW primality test (BPSW) \cite{baillie1980} or Miller-Rabin (MR) \cite{rabin1980} \cite{miller1976} are used instead of AKS when searching for large primes. Probabilistic primality tests are by definition non-deterministic and may erroneously report a composite integer as being prime. Composite integers which pass a probabilistic primality test are relatively rare and are known as psuedoprimes (PSPs) for the respective test \cite{wagstaff1983}. When generating primes for cryptographic purposes, probabilistic primality tests are often combined or repeated with different parameters in order to achieve an acceptable error-bound that makes it almost certain that no composite integer will pass. However, reducing the error-bound requires additional compute and increases running-time, creating a trade-off.

We present a new deterministic primality test that operates in polynomial time with a time complexity of $\tilde{O}(\log^3(n))$. This efficiency gain opens new avenues for practical applications, particularly in cryptography, where fast and reliable primality testing is desirable \cite{pomerance1984}. Our main theorem posits a condition for an odd integer \( n \) to be prime, based on specific modular congruences related to the binomial transforms of powers of $2$. The basis for our test is the following main theorem: Let \( n \) be an odd integer satisfying \( 2^{n-1} \equiv 1 \pmod{n} \). Denote \( D \) as the least integer strictly greater than \( 2 \) and less than \( n \) which does not divide \( n-1 \). Then, \( n \) is prime if and only if a set of simultaneous modular congruences involving \( D \), \( n \), and binomial coefficients hold.

This paper is structured as follows: We begin by presenting the main theorem and its proof, substantiated by supporting lemmas. The proof of our main theorem demonstrates the test's validity for odd prime numbers and its failure for odd composite numbers. Through this, we establish the deterministic nature of our test. We then describe the algorithm used to compute our test and analyze its computational complexity. We also give pseudocode for our test to show how it can be implemented.

\section{Main Theorem}

\begin{theorem}
\label{theorem:1}
    Let $n$ be an odd integer $> 3$ satisfying $2^{n-1} \equiv 1 \pmod{n}$. Denote $D$ as the least integer greater than $2$ and less than $n$ which does not divide $n-1$. Then, $n$ is prime if and only if the following congruence holds:
    \begin{align}
        1 + 2^{\left\lfloor \frac{n-1}{D} \right\rfloor} \equiv \left(1 + 2^{\left\lfloor \frac{n-1}{D} \right\rfloor}\right)^{n} \equiv \sum_{k=0}^{n} \binom{n}{k} 2^{\left\lfloor \frac{k}{D} \right\rfloor} \pmod{n}
    \end{align}
\end{theorem}

\subsection{Supporting Lemmas}
\begin{lemma}
\label{lemma:1}
    Let $n$ be an odd composite integer $> 3$ satisfying $2^{n-1} \equiv 1 \pmod{n}$. Denote $D$ as the least integer greater than $2$ and less than $n$ which does not divide $n-1$. Then, $\left\lfloor\frac{n-1}{D}\right\rfloor \not= \text{ord}_n(2)$.
\end{lemma}
\begin{proof}
We are given odd composite $n > 3$ with $2^{n-1} \equiv 1 \pmod{n}$. By the properties of the order of an integer modulo composite $n$, the smallest $k$ such that $2^k \equiv 1 \pmod{n}$, that is $k = \text{ord}_n(2)$, must be a divisor of $n-1$. Hence, $\text{ord}_n(2) \mid n-1$. Since $\left\lfloor\frac{n-1}{D}\right\rfloor$ is strictly less than $n-1$ and $D$ does not divide $n-1$, it follows that $2^{\left\lfloor\frac{n-1}{D}\right\rfloor} \not\equiv 1 \pmod{n}$ and therefore, $\left\lfloor\frac{n-1}{D}\right\rfloor \not= \text{ord}_n(2)$.
\end{proof}

\subsection{Proof of the Main Theorem}
\begin{proof}[Proof of Theorem \ref{theorem:1}]
Let \( n \) be an odd integer $>3$ satisfying $2^{n-1} \equiv 1 \pmod{n}$.

Define \( f(x) = 2^{\left\lfloor \frac{x-1}{D} \right\rfloor} \) and \( D \) as the least integer greater than \( 2 \) that does not divide \( n-1 \). We begin with the congruence:
\begin{align}
(1 + f(n))^n \equiv \sum_{k=0}^{n} \binom{n}{k} f(k+1) \pmod{n}
\end{align}

Using the binomial theorem, we expand the left-hand side:
\begin{align}
\sum_{k=0}^{n} \binom{n}{k} f(n)^k \equiv \sum_{k=0}^{n} \binom{n}{k} f(k+1) \pmod{n}
\end{align}

Rewriting this, we must have:
\begin{align}
\sum_{k=0}^{n} \binom{n}{k} \left(f(n)^k - f(k+1)\right) \equiv 0 \pmod{n}.
\end{align}

As a necessary condition of our test, we also require:
\begin{align}
      \sum_{k=0}^{n} \binom{n}{k} f(n)^k \equiv \sum_{k=0}^{n} \binom{n}{k} f(k+1) \equiv 1 + f(n) \pmod{n}
\end{align}

By the binomial theorem, we isolate the inner terms:
\begin{align}
      1 + f(n)^n + \sum_{k=1}^{n-1} \binom{n}{k} f(n)^k \equiv 1 + f(n) + \sum_{k=1}^{n-1} \binom{n}{k} f(k+1) \equiv 1 + f(n) \pmod{n}
\end{align}

Setting common terms to zero:
\begin{align} \label{equation:congruence1}
      \sum_{k=1}^{n-1} \binom{n}{k} f(n)^k \equiv \sum_{k=1}^{n-1} \binom{n}{k} f(k+1) \equiv 0 \pmod{n}
\end{align}

We have defined $n$ such that $2^{n-1} \equiv 1 \pmod{n}$, which implies $2^n - 2 \equiv \sum_{k=1}^{n-1} \binom{n}{k} \equiv 0 \pmod{n}$. Plugging it in:
\begin{align}
      \sum_{k=1}^{n-1} \binom{n}{k} \equiv \sum_{k=1}^{n-1} \binom{n}{k} f(n)^k \equiv \sum_{k=1}^{n-1} \binom{n}{k} f(k+1) \equiv 0 \pmod{n}
\end{align}

Subtracting $\sum_{k=1}^{n-1} \binom{n}{k}$ gives:
\begin{align}
\left(\sum_{k=1}^{n-1} \binom{n}{k} f(n)^k\right) - \sum_{k=1}^{n-1} \binom{n}{k} \equiv \left(\sum_{k=1}^{n-1} \binom{n}{k} f(k+1)\right) - \sum_{k=1}^{n-1} \binom{n}{k} \equiv 0 \pmod{n}
\end{align}

Combining the summations:
\begin{align}
\sum_{k=1}^{n-1} \left(\binom{n}{k} f(n)^k - \binom{n}{k}\right) \equiv \sum_{k=1}^{n-1} \left(\binom{n}{k} f(k+1) - \binom{n}{k}\right) \equiv 0 \pmod{n} \\
\sum_{k=1}^{n-1} \left(\binom{n}{k} f(n)^k - \binom{n}{k} f(k+1) - \binom{n}{k}\right) \equiv 0 \pmod{n}
\end{align}

Factoring out the common $\binom{n}{k}$ from the inner terms reveals:
\begin{align}
\sum_{k=1}^{n-1} \binom{n}{k} \left(f(n)^k - f(k+1) - 1\right) \equiv 0 \pmod{n}
\end{align}

For the above congruence, there are three potential cases we must examine.

\textbf{Case 1:} $n$ is prime
    
In this case, the congruence always holds. By the binomial theorem, $\binom{n}{k} \equiv 0 \pmod{n}$ for $0 < k < n$ and the congruence simplifies trivially to zero.

\textbf{Case 2:} $n$ is composite and $f(n) \equiv 1 \pmod{n}$

In this case, the congruence may or may not hold. With $f(n) \equiv 1 \pmod{n}$, the congruence simplifies significantly, making it possible:
\begin{align}
    \sum_{k=1}^{n-1} \binom{n}{k} \left(f(n)^k - f(k+1) - 1\right) \equiv 0 \pmod{n} \\
    \sum_{k=1}^{n-1} \binom{n}{k} \left(1^k - f(k+1) - 1\right) \equiv 0 \pmod{n} \\
    \sum_{k=1}^{n-1} \binom{n}{k} \cdot \left(-f(k+1)\right) \equiv 0 \pmod{n}
\end{align}

\textbf{Case 3:} $n$ is composite and $f(n) \not\equiv 1 \pmod{n}$

In this case, the congruence cannot hold.

Since $\sum_{k=1}^{n-1} \binom{n}{k} \equiv 0 \pmod{n}$, we may add or subtract $\sum_{k=1}^{n-1} \binom{n}{k}$ from our congruence an arbitrary number of times and $n$ must still divide the sum. The same applies to $\sum_{k=1}^{n-1} \binom{n}{k} f(n)^k$ and $\sum_{k=1}^{n-1} \binom{n}{k} f(k+1)$. Therefore, we surmise that the following must hold for all $W,X,Y \in \mathbb{Z}$:
\begin{align}
W \left(\sum_{k=1}^{n-1} \binom{n}{k} f(n)^k\right) - X \left(\sum_{k=1}^{n-1} \binom{n}{k} f(k+1)\right) - Y \left(\sum_{k=1}^{n-1} \binom{n}{k}\right) \equiv 0 \pmod{n} \\
\left(\sum_{k=1}^{n-1} \binom{n}{k} f(n)^k W\right) - \left(\sum_{k=1}^{n-1} \binom{n}{k} f(k+1) X\right) - \left(\sum_{k=1}^{n-1} \binom{n}{k} Y\right) \equiv 0 \pmod{n} \\
\sum_{k=1}^{n-1} \binom{n}{k} \left( W \cdot f(n)^k - X \cdot f(k+1) - Y\right) \equiv 0 \pmod{n}
\end{align}

If $\binom{n}{k} \not\equiv 0 \pmod{n}$ for any $k$, as we know it must be for some $k$, and $f(n)^k \not\equiv f(k+1) \pmod{n}$, then the summation within our congruence may sum to any value by adjusting the values of $W$, $X$, and $Y$. For the congruence to hold, we would require all integers to be equivalent to $0 \pmod{n}$. However, this is a contradiction, as $n\not=1$ and it is impossible. Therefore, to prove that the congruence cannot hold, it suffices to show that $f(n)^k \not\equiv f(k+1) \pmod{n}$ for some $k$ with $\binom{n}{k} \not\equiv 0 \pmod{n}$.

For composite \( n \), Kummer's theorem \cite{kummer1857} states that \( \binom{n}{k} \) is divisible by \( n \) if and only if at least one of the base-\( p \) digits of \( k \) is greater than the corresponding digit of \( n \), where \( p \) is a prime dividing \( n \). For these values of \( k \), the congruence \( f(n)^k \equiv f(k+1) \pmod{n} \) is unlikely because \( f(n)^k \) and \( f(k+1) \) represent different powers of 2 modulo \( n \). It would necessarily imply $2^{\left\lfloor \frac{n-1}{D} \right\rfloor k} \equiv 2^{\left\lfloor \frac{k}{D} \right\rfloor} \pmod{n}$. This can only occur at values $k$ in the range $0 < k < n$ which are solutions to the modular congruence:
\begin{align}
    \left\lfloor \frac{n-1}{D} \right\rfloor k - \left\lfloor \frac{k}{D} \right\rfloor \equiv 0 \pmod{\text{ord}_n(2)}
\end{align}

\begin{itemize}
    \item \textbf{Cycling of \( f(n)^k = 2^{\left\lfloor \frac{n-1}{D} \right\rfloor k} \) Modulo \( n \):} This term cycles through all possible residues of powers of 2 modulo \( n \), as \( k \) varies from 1 to \( n-1 \). This is because \( \left\lfloor \frac{n-1}{D} \right\rfloor \) is fixed for a given \( n \), and as \( k \) increases, the exponent \( \left\lfloor \frac{n-1}{D} \right\rfloor k \) effectively cycles through various powers.
    \item \textbf{Behavior of \( f(k+1) = 2^{\left\lfloor \frac{k}{D} \right\rfloor} \) Modulo \( n \):} In contrast, this term does not cycle through all residues in the same way. The exponent \( \left\lfloor \frac{k}{D} \right\rfloor \) changes more slowly with \( k \), as it's the floor of a fraction. Therefore, for multiple consecutive values of \( k \), the value of \( 2^{\left\lfloor \frac{k}{D} \right\rfloor} \) remains the same.
\end{itemize}    

Applying the Pigeonhole Principle \cite{rosen2012}, there must exist at least one value of \( k \) such that \( \binom{n}{k} \left(f(n)^k - f(k+1)\right) \not\equiv 0 \pmod{n} \). This non-zero term in the sum, when multiplied by the non-zero binomial coefficient, ensures that the sum cannot be congruent to zero modulo \( n \) for all possible permutations of $W, X, Y$.

\textbf{Conclusion:}

When $n$ is an odd prime integer $>3$, the congruence holds. When $n$ is an odd composite integer $>3$, by Lemma \ref{lemma:1} we have $f(n) \not\equiv 1 \pmod{n}$ and therefore, the congruence cannot hold. Hence, the theorem is proven.
\end{proof}

\section{Algorithm} \label{section:algorithm}
\textbf{INPUT}: An integer $n > 1$.
\begin{center}
    \begin{enumerate}
        \item If $n \equiv 0 \mod{2}$:
            \begin{enumerate}
                \item If $n$ equals $2$, output PRIME.
                \item Otherwise, output COMPOSITE.
            \end{enumerate}
        \item If $n$ equals $3$, output PRIME.
        \item If $2^{n-1} \not\equiv 1 \pmod{n}$, output COMPOSITE.
        \item Find the least integer $D$ that is greater than 2 and less than $n$ which does not divide $n-1$.
        \item Set $A = 2^{\left\lfloor \frac{n-1}{D} \right\rfloor} \bmod{n}$.
        \item Set $B = (1 + A)^n \bmod{n}$.
        \item If $B \not\equiv 1 + A \pmod{n}$, output COMPOSITE.
        \item Set $C = \sum_{k=0}^{n} \binom{n}{k} 2^{\left\lfloor \frac{k}{D} \right\rfloor} \bmod{n}$.
        \item If $C \not\equiv 1 + A \pmod{n}$, output COMPOSITE.
        \item Output PRIME;
    \end{enumerate}
\end{center}

\subsection{Time Complexity Analysis} \label{subsection:timecomplexity}

\subsubsection{Algorithm Overview}
The given algorithm is a primality test that involves several computational steps, including modular arithmetic and polynomial exponentiation in the ring \(\mathbb{Z}/n\mathbb{Z}\).

\subsubsection{Analysis of Individual Operations}
\begin{enumerate}
    \item \textbf{Check for Even \( n \)}:
    
        This step involves calculating $n \bmod{2}$ and has a time complexity of \( O(1) \).

    \item \textbf{Modular Exponentiation \( 2^{n-1} \mod n \)}:
    
        This step requires modular exponentiation with a \( \log(n) \)-digit base and a \( \log(n) \)-digit exponent. The time complexity of modular exponentiation is \( O(\log(n) M(n)) \).

    \item \textbf{Finding \( D \)}:
    
        Finding the least integer \( D > 2 \) that does not divide \( n-1 \) takes at most \( O(\log(n)) \) steps, with each step requiring \( O(1) \) time for the mod operation. Hence, the overall complexity is \( O(\log(n)) \).

    \item \textbf{Computing \( A \) and \( B \)}:
    
        Each of these steps involves modular exponentiation similar to Step 2, and thus each has a time complexity of \( O(\log(n) M(n)) \).

    \item \textbf{Computing \( C \)}:
    
        Computing \( C \) involves exponentiating a polynomial in the ring \(\mathbb{Z}/n\mathbb{Z}\) with \( O(\log(n)) \) terms and summing the coefficients. The mathematics underlying the computation of \( C \) is described and proven in \S \ref{section:polyrings}.
        \begin{enumerate}
            \item Summing the polynomial coefficients can be done in \( O(\log^2(n)) \) time.
            \item Exponentiation using repeated squaring takes \( O(\log(n)) \) steps, and each step requires \( O(M(n)\log(n)) \) time due to the multiplication of polynomials of size \( O(\log(n)) \).
        \end{enumerate}
         Therefore, the overall complexity for computing \( C \) is \( O(\log^2(n) M(n)) \).
         
    \item \textbf{Comparisons}:
    
        The final steps involve comparisons which are \( O(1) \) operations.
\end{enumerate}

\subsubsection{Overall Time Complexity}
The dominant time complexity in the algorithm comes from computing \( C \). Therefore, the overall time complexity of the algorithm is \( T(n) = O(\log^2(n) M(n)) \).

Harvey and van Der Heoven (2021) have given an algorithm for integer multiplication which has a time complexity $M(n) = O(\log(n) \log\log(n))$ \cite{harveyvanderhoeven2021}. This would give our algorithm an overall time complexity of:
\begin{align}
    T(n) = O(\log^2(n) M(n)) = O(\log^2(n) \log(n) \log\log(n)) = O(\log^3(n) \log\log(n)) = \tilde{O}(\log^3(n))
\end{align}

\subsubsection{Conclusion}
The overall complexity is polynomial in the size of \( n \) when expressed in terms of bit operations, making the algorithm efficient for large values of \( n \).

\section{Efficient Calculations via Polynomial Rings} \label{section:polyrings}
In this section, we define a special polynomial ring $R$ with a modular variation $M$, and show how $M$ can be used to efficiently calculate the value of $\sum_{k=0}^{n} \binom{n}{k} 2^{\left\lfloor \frac{k}{D} \right\rfloor} \pmod{n}$. The standard approach to calculating this value requires evaluating $\binom{n}{k} 2^{\left\lfloor \frac{k}{D} \right\rfloor} \pmod{n}$ for each $k$ and summing the results, which takes time exponential in $n$. Conversely, our approach offers an efficient polynomial time complexity of $\tilde{O}(\log(D) \cdot \log^2(n))$ (See: \S \ref{subsection:timecomplexity}).

\subsection{Ring Definition}

\begin{definition}[Polynomial ring $R$] \label{definition:ring}
We construct a polynomial ring \(R = \mathbb{Z}[x]\) in which addition is carried out as usual, and multiplication is followed by polynomial degree reduction via a special substitution function, denoted $\Phi$ \cite{shunia2023polynomial}. The multiplication operation \(\ast\) is defined as follows:
\begin{align}
P(x) \ast Q(x) = \Phi(P(x) \cdot Q(x)) \text{ for all } P(x), Q(x) \in R,
\end{align}
\(\Phi\) is an operation that enforces any defined substitution rules for the polynomial's terms upon multiplication. In our case, for the generator \(x\), we have:
\begin{align}
x \ast x^{d-1} = x^d = \Phi(x^d) = N, \text{ where } N \in R
\end{align}

For any polynomial in our ring $R$, the function \( \Phi \) is distributed to the individual terms and implicitly applied to reduce terms. Whenever the term $x^d$ appears, it is replaced with its defined mapping. The mappings in $\Phi$ are extended to terms of higher degrees, meaning $\Phi(x^{d+k}) = \Phi(x^d \ast x^k) = N x^k$, for $k > 1$. $\Phi$ is applied recursively to the polynomial until and its terms until the degree of the polynomial is less than $d$. For terms which do not match a defined substitution rule, $\Phi$ returns them as they are.
\end{definition}

\begin{example}
We take the ring $R$ as defined in Definition \ref{definition:ring} with $N = 2$, $d = 3$. Hence, $\Phi(x^3) = 2$. $P(x) := 1 + x + 3x^3 + x^{4} + x^{6}, P(x) \in R$.
\begin{align}
    \Phi(P(x)) &= \Phi(1 + x + 3x^3 + x^{4} + x^{6}) \\
    &= \Phi(1) + \Phi(x) + \Phi(3x^3) + \Phi(x^{4}) + \Phi(x^{6}) \\
    &= 1 + x + \Phi(2 \cdot 3) + \Phi(2 \cdot x) + \Phi(2 \cdot x^3) \\
    &= 1 + x + 6 + 2x + \Phi(2 \cdot 2) \\
    &= 7 + 3x + 4 \\
    &= 11 + 3x
\end{align}
\end{example}

\subsection{Ring Axioms}
We assert that the ring \( R \) with the modified operation \(\ast\) still satisfies the standard ring axioms. Specifically, we show that \((R, +, \ast)\) is associative, commutative (with respect to addition), and has an additive identity and an additive inverse for every element. Additionally, the distributive property of multiplication over addition is preserved under the operation \(\ast\).

\subsubsection{Multiplicative Properties}
\begin{proposition}[Distributivity of \(\ast\)] \label{proposition:ring:1}
The operation \(\ast\) is distributive over addition in the ring \(R\).
\end{proposition}
\begin{proof}
The modified multiplication \(\ast\) is distributive over addition because for any \( P(x), Q(x), S(x) \in R \),
\begin{align}
    P(x) \ast (Q(x) + S(x)) &= \Phi(P(x) \cdot (Q(x) + S(x))) \\
    &= \Phi(P(x) \cdot Q(x) + P(x) \cdot S(x)) \\
    &= \Phi(P(x) \cdot Q(x)) + \Phi(P(x) \cdot S(x)) \\
    &= P(x) \ast Q(x) + P(x) \ast S(x)
\end{align}
Where the second equality uses the distributive property of the standard multiplication in \( \mathbb{Z}[x] \) and the linearity of \(\Phi\) with respect to polynomial addition.
\end{proof}

\begin{proposition}[Associativity of \(\ast\)] \label{proposition:ring:2}
The multiplication operation \(\ast\) in the ring \(R\) is associative.
\end{proposition}
\begin{proof}
To prove associativity, we need to show that for any \( P(x), Q(x), S(x) \in R \):
\begin{align}
    (P(x) \ast Q(x)) \ast S(x) = P(x) \ast (Q(x) \ast S(x))
\end{align}
Expanding the left-hand side:
\begin{align}
    (P(x) \ast Q(x)) \ast S(x) &= \Phi(P(x) \cdot Q(x)) \ast S(x) \\
    &= \Phi(\Phi(P(x) \cdot Q(x)) \cdot S(x))
\end{align}
Similarly, for the right-hand side:
\begin{align}
    P(x) \ast (Q(x) \ast S(x)) &= P(x) \ast \Phi(Q(x) \cdot S(x)) \\
    &= \Phi(P(x) \cdot \Phi(Q(x) \cdot S(x)))
\end{align}
Since the standard multiplication in \(\mathbb{Z}[x]\) is associative and \(\Phi\) is a well-defined operation that respects this associativity, we have:
\begin{align}
    \Phi(\Phi(P(x) \cdot Q(x)) \cdot S(x)) = \Phi(P(x) \cdot \Phi(Q(x) \cdot S(x)))
\end{align}
Which shows that:
\begin{align}
    (P(x) \ast Q(x)) \ast S(x) = P(x) \ast (Q(x) \ast S(x))
\end{align}
\end{proof}

\subsubsection{Additive Properties}
\begin{proposition}[Preservation of additive properties] \label{proposition:ring:3}
The commutative and associative properties of addition, and the existence of an additive identity and inverses, are maintained in the ring \(R\). 
\end{proposition}
\begin{proof}
The additive structure of \(R\) remains unchanged. Thus, the commutative and associative properties of addition, and the existence of an additive identity and inverses, are inherited directly from \( \mathbb{Z}[x] \).
\end{proof}

\subsection{Modular Ring Definition}
\begin{definition}[Modular polynomial ring $M$]  \label{definition:modularring}
Let \( R = \mathbb{Z}[x] \) be our polynomial ring as defined in Definition \ref{definition:ring}, where the multiplication is modified by a substitution function \(\Phi\) as described previously. Let \( n \) be a positive integer. We define the modular variation of \( R \), denoted as \( M \), to be the ring of polynomials with coefficients in \( \mathbb{Z}/n\mathbb{Z} \) and with multiplication modified by a corresponding substitution function \(\Phi_M\). Formally, \( M = (\mathbb{Z}/n\mathbb{Z})[x] \), where the coefficients of the polynomials in \( M \) are taken modulo \( n \), and the multiplication in \( M \) is given by
\begin{align}
    P(x) \ast Q(x) = \Phi_M(P(x) \cdot Q(x)) \text{ for all } P(x), Q(x) \in M,
\end{align}
\(\Phi_M\) is defined analogously to \(\Phi\) but operates within the context of the coefficients being in \( \mathbb{Z}/n\mathbb{Z} \).
\end{definition}

\begin{proposition} \label{proposition:modularring:1}
The ring \( M = (\mathbb{Z}/n\mathbb{Z})[x] \) with the modified multiplication operation \(\ast\), as defined by the substitution function \(\Phi_M\), inherits the standard ring axioms from \( R = \mathbb{Z}[x] \).
\end{proposition}
\begin{proof}
Since the ring \( M \) is structurally analogous to \( R \) with the only difference being the coefficient domain (\(\mathbb{Z}/n\mathbb{Z}\) instead of \(\mathbb{Z}\)), and the modified multiplication operation \(\ast\) in \( M \) is defined similarly to \( R \) using \(\Phi_M\), analogous to \(\Phi\), \( M \) inherits the ring properties of \( R \). This includes the associativity and commutativity of addition, the existence of an additive identity and inverses, the distributivity of multiplication over addition, and the associativity of multiplication. These properties are preserved under the transition from \(\mathbb{Z}\) to \(\mathbb{Z}/n\mathbb{Z}\) coefficients and the analogous definition of \(\ast\) in \( M \).
\end{proof}

\subsection{Ring Calculations}
We now demonstrate how our modular polynomial ring $M$ can be used to efficiently calculate the value of $\sum_{k=0}^{n} \binom{n}{k} 2^{\left\lfloor \frac{k}{D} \right\rfloor} \pmod{n}$.

In an earlier paper relating the central binomial coefficients and Gould's sequence to polynomial rings \cite{shunia2023polynomial}, we showed how a multivariate polynomial ring, analogous to the univariate polynomial ring we have defined herein, can be used generally to compute the binomial transforms of recursive integer sequences. We apply the same technique here.

\begin{theorem} \label{theorem:2}
Let $n$, $k$ be non-negative integers. Let $D$ be an integer $>2$. Define the ring $M$ as in Definition \ref{definition:modularring} with $d=D-1$, $N=2$, hence $\Phi(x^{D-1}) = 2$. $P(x) := x, P(x) \in M$. Taking the sum of the coefficients modulo $n$ in the polynomial expansion of \( P(x)^k \), gives $2^{\left\lfloor \frac{k}{D} \right\rfloor} \pmod{n}$.
\end{theorem}
\begin{proof}
Examining $D = 2$, we can see:
\begin{align*}
P(x)^0 &= 1 = 2^{\left\lfloor 0/2 \right\rfloor} \\
P(x)^1 &= x = 1 = 2^{\left\lfloor 1/2 \right\rfloor} \\
P(x)^2 &= x^2 = 2 = 2^{\left\lfloor 2/2 \right\rfloor}\\
P(x)^3 &= x^3 = 2x = 2 = 2^{\left\lfloor 3/2 \right\rfloor}\\
P(x)^4 &= x^4 = 2x^2 = 4 = 2^{\left\lfloor 4/2 \right\rfloor}\\
P(x)^5 &= x^5 = 4x = 4 = 2^{\left\lfloor 5/2 \right\rfloor}\\
P(x)^6 &= x^6 = 4x^2 = 8 = 2^{\left\lfloor 6/2 \right\rfloor}\\
\vdots
\end{align*}

We proceed by induction.

\textbf{Base Case:}
For \( k = 0 \), we have \( P(x)^0 = 1 \), and the sum of coefficients is \( 2^{\left\lfloor \frac{0-1}{D} \right\rfloor} = 2^{0} = 1 \).

\textbf{Inductive Step:}
Assume the theorem holds for some \( k \geq 0 \), i.e., the sum of coefficients modulo \( n \) in \( P(x)^k \) is \( 2^{\left\lfloor \frac{k}{D} \right\rfloor} \pmod{n} \). We need to show it also holds for \( k+1 \).

Consider \( P(x)^{k+1} = P(x)^k \ast P(x) \). By the definition of \( \ast \) and \( \Phi \), the degree of \( P(x)^{k+1} \) gets reduced by \( \Phi \) every time it reaches \( D \). The number of times this reduction happens is \( \left\lfloor \frac{k}{D} \right\rfloor \). Therefore, the sum of coefficients in \( P(x)^{k+1} \) should be \( 2^{\left\lfloor \frac{k+1}{D} \right\rfloor} \), as each reduction by \( \Phi \) doubles the sum of coefficients. Hence, the theorem holds for \( k+1 \).

\textbf{Conclusion:}
By the principle of mathematical induction, the theorem is proven.
\end{proof}

\begin{theorem} \label{theorem:3}
Let $n$ an integer $>0$. Let $D$ be an integer $>2$. Define the ring $M$ as in Definition \ref{definition:modularring} with $d=D-1$, $N=2$, hence $\Phi(x^{D-1}) = 2$. $P(x) := x, P(x) \in M$. Then taking the sum of the coefficients modulo $n$ in the polynomial expansion of \( (1 + P(x))^n \) is equivalent to $\sum_{k=0}^{n} \binom{n}{k} 2^{\left\lfloor \frac{k}{D} \right\rfloor} \pmod{n}$.
\end{theorem}
\begin{proof}
By the binomial theorem, we have:
\begin{align}
    (1 + x)^n = \sum_{k=0}^{n} \binom{n}{k} P(x)^{k}
\end{align}
Hence, when we evaluate this polynomial at \( x = 1 \), we sum the coefficients of the polynomial to get:
\begin{align}
    \sum_{k=0}^{n} \binom{n}{k} 2^{\left\lfloor \frac{k}{D} \right\rfloor} \quad \text{(by Theorem \ref{theorem:2})}
\end{align}
This completes the proof.
\end{proof}

\section{Implementation Details}
\subsection{Reference Implementation}
 A sample open source .NET implementation, with test data, is available on the author's Github page \cite{githubrepo}.

 \subsection{Pseudocode Implementation}
To demonstrate how our test may be implemented, we offer a pseudocode implementation of the key functions involved.

\subsubsection{IsPrime Function}

\begin{algorithmic}
\Require An integer $n > 1$
\Function{IsPrime}{$n$}
    \If{$n \bmod 2 = 0$}
        \If{$n = 2$}
            \State \Return \textbf{true} \Comment{$n$ is prime}
        \Else
            \State \Return \textbf{false} \Comment{$n$ is composite}
        \EndIf
    \EndIf
    \If{$n = 3$}
        \State \Return \textbf{true} \Comment{$n$ is prime}
    \EndIf
    \State $fermat \gets \Call{Pow}{2, n-1, n}$ \Comment{Fermat pseudoprime test to base 2}
    \If{$fermat \neq 1$}
        \State \Return \textbf{false} \Comment{$n$ is composite}
    \EndIf
    \State $D \gets 2$
    \State $log \gets \Call{Log2}{n}$
    \For{$i \gets 3$ \textbf{to} $\Call{Max}{log, 3}$}
        \State $D \gets i$
        \State $m \gets (n-1) \bmod D$
        \If{$m \neq 0$}
            \State \textbf{break}
        \EndIf
    \EndFor
    \State $A \gets \Call{Pow}{2, \lfloor (n-1) / D \rfloor, n}$
    \State $expectedValue \gets (A + 1) \bmod n$
    \State $B \gets \Call{Pow}{A + 1, n, n}$
    \If{$B \neq expectedValue$}
        \State \Return \textbf{false} \Comment{$n$ is composite}
    \EndIf
    \State $polyDegree \gets D - 1$ \Comment{Subtract 1 to account for zero indexing in arrays}
    \State $poly \gets \Call{PolyPow}{[1, 1], n, n, polyDegree, [2]}$
    \State $C \gets \Call{PolyEval}{poly, 1} \bmod n$ \Comment{Evaluate at x=1 to sum coefficients}
    \If{$C \neq expectedValue$}
        \State \Return \textbf{false} \Comment{$n$ is composite}
    \EndIf
    \State \Return \textbf{true} \Comment{$n$ is prime}
\EndFunction
\end{algorithmic}

\subsubsection{PolyPow Function}
\begin{algorithmic}
\Function{PolyPow}{$poly_A$, $k$, $n$, $d$, $polyMapping$}
    \State $polyB \gets [1]$ \Comment{Initialize polyB as a polynomial with constant term 1}
    \While{$k > 0$}
        \If{$k \bmod 2 = 1$}
            \State $polyB \gets \Call{PolyMul}{polyA, polyB, n}$ \Comment{Multiply polynomials modulo $n$}
            \State $polyB \gets \Call{PolyReduce}{polyB, d, polyMapping, n}$ \Comment{Reduce degree of polyB}
            \If{$k = 1$}
                \State \textbf{break}
            \EndIf
        \EndIf
        \State $polyA \gets \Call{PolyMul}{polyA, polyA, n}$ \Comment{Square polyA modulo $n$}
        \State $polyA \gets \Call{PolyReduce}{polyA, d, polyMapping, n}$ \Comment{Reduce degree of polyA}
        \State $k \gets k / 2$
    \EndWhile
    \State \Return $polyB$
\EndFunction
\end{algorithmic}

\subsubsection{PolyReduce Function}
\begin{algorithmic}
\Function{PolyReduce}{$polyA$, $d$, $mappingPoly$, $n$}
    \If{$\Call{Length}{polyA} \leq d$}
        \State \Return $polyA$
    \EndIf

    \State $polyB \gets \Call{Clone}{polyA}$ \Comment{Copy the polynomial to a new array}
    \State $polyDegree \gets \Call{Degree}{mappingPoly}$ \Comment{Find degree of the mapping polynomial}
    \State $degreeDelta \gets d - polyDegree$

    \For{$i \gets \Call{Length}{polyB} - 1$ \textbf{downto} $d + 1$}
        \If{$polyB[i] = 0$}
            \State \textbf{continue}
        \EndIf
        \For{$j \gets i - 1 - degreeDelta$, $k \gets polyDegree$ \textbf{downto} $0$}
            \State $polyB[j] \gets polyB[j] + polyB[i] \times mappingPoly[k]$ \Comment{Degree reduction step}
        \EndFor
        \State $polyB[i] \gets 0$
    \EndFor

    \State $polyC \gets \text{new array of size } d + 1$
    \For{$i \gets 0$ \textbf{to} $\min(\Call{Length}{polyC}, \Call{Length}{polyB}) - 1$}  \Comment{Take coefficients modulo $n$}
        \State $polyC[i] \gets polyB[i]$
        \If{$n \neq 0$}
            \State $polyC[i] \gets polyC[i] \bmod n$
        \EndIf
    \EndFor

    \State \Return $polyC$
\EndFunction
\end{algorithmic}

\section{Acknowledgements}
The author would like to thank the kind users at \url{mersenneforum.org} for their helpful feedback.

\begingroup
\raggedright
\bibliographystyle{unsrtnat}
\bibliography{main}
\endgroup

\end{document}