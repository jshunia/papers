\pdfoutput=1
\documentclass{article}
\usepackage{fullpage}
\usepackage{amsmath, amssymb, amsthm}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[numbers]{natbib}
\usepackage{csquotes}
\usepackage{url}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{algorithmicx}
\setlength{\parskip}{0.5em}
\setlength{\parindent}{0pt}
\theoremstyle{plain}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\usepackage{graphicx}
\usepackage{multicol}

\title{An Efficient Deterministic Primality Test}
\author{Joseph M. Shunia}
\date{December 2023}

\begin{document}

\maketitle
\begin{center}
    [Draft]
\end{center}

\begin{abstract}
A deterministic primality test with a polynomial time complexity of $O(\log(n)^3 \log\log(n))$ is presented. The test posits that an integer $n$ satisfying the conditions of the main theorem is prime. Combining elements of number theory and combinatorics, the proof operates on the basis of simultaneous modular congruences relating to binomial transforms of powers of two.
\end{abstract}

\section{Introduction}

Primality testing has seen remarkable advancements over the past few decades. A significant breakthrough in this field was the AKS primality test, introduced by Agrawal, Kayal, and Saxena (2002) \cite{aks2002}. The AKS test was the first to offer determinism and polynomial-time complexity, a monumental achievement that resolved a longstanding open question in computational number theory \cite{goldreich2008}. However, despite its theoretical importance, the AKS test has practical limitations due to its relatively high polynomial time complexity, rendering it inefficient for most applications. Agrawal, Kayal, and Saxena gave a time complexity of $O(\log(n)^{12})$ for the AKS test \cite{aks2002}. This bound was lowered significantly by Lenstra and Pomerance (2011) to $O(\log^6(n))$ \cite{lenstra2011}. Despite this reduction, AKS remains impractical and is mostly unused.

In the field of cryptography, the unique properties of prime numbers are widely exploited to create cryptographic primitives. It is often the case that many large primes must be generated in rapid succession \cite{lenstra1987}. To make these cryptographic operations practical, fast probabilistic primality tests such as the Baille-PSW primality test (BPSW) \cite{baillie1980} or Miller-Rabin (MR) \cite{rabin1980} \cite{miller1976} are used instead of AKS when searching for large primes. Probabilistic primality tests are by definition non-deterministic and may erroneously report a composite integer as being prime. Composite integers which pass a probabilistic primality test are relatively rare and are known as psuedoprimes (PSPs) for the respective test \cite{wagstaff1983}. When generating primes for cryptographic purposes, probabilistic primality tests are often combined or repeated with different parameters in order to achieve an acceptable error-bound that makes it almost certain that no composite integer will pass. However, reducing the error-bound requires additional compute and increases running-time, creating a trade-off.

We present a new deterministic primality test that operates in polynomial time with a time complexity of $O(\log(n)^3 \log\log(n))$. This efficiency gain opens new avenues for practical applications, particularly in cryptography, where fast and reliable primality testing is desirable \cite{pomerance1984}. Our main theorem posits a condition for an odd integer \( n \) to be prime, based on specific modular congruences related to the binomial transforms of powers of $2$. The basis for our test is the following main theorem: Let \( n \) be an odd integer satisfying \( 2^{n-1} \equiv 1 \pmod{n} \). Denote \( D \) as the least integer strictly greater than \( 2 \) and less than \( n \) which does not divide \( n-1 \). Then, \( n \) is prime if and only if a set of simultaneous modular congruences involving \( D \), \( n \), and binomial coefficients hold.

This paper is structured as follows: We begin by presenting the main theorem and its proof, substantiated by two critical lemmas. The first lemma demonstrates the test's validity for odd prime numbers, while the second confirms its failure for odd composite numbers. Through these lemmas, we establish the deterministic nature of our test. We then describe the algorithm used to compute our test and analyze its computational complexity. We also give a pseudocode implementation for our test to show how it can be implemented.

\section{Main Theorem}

\begin{theorem}
\label{theorem:1}
    Let $n$ be an odd integer $> 3$ satisfying $2^{n-1} \equiv 1 \pmod{n}$. Denote $D$ as the least integer greater than $2$ and less than $n$ which does not divide $n-1$. Then, $n$ is prime if and only if the following congruence holds:
    \begin{align}
        1 + 2^{\left\lfloor \frac{n-1}{D} \right\rfloor} \equiv \left(1 + 2^{\left\lfloor \frac{n-1}{D} \right\rfloor}\right)^{n} \equiv \sum_{k=0}^{n} \binom{n}{k}2^{\left\lfloor \frac{k}{D} \right\rfloor} \pmod{n}
    \end{align}
\end{theorem}

\subsection{Supporting Lemmas}
\begin{lemma}
\label{lemma:1}
    Let $n$ be an odd composite integer $> 3$ satisfying $2^{n-1} \equiv 1 \pmod{n}$. Denote $D$ as the least integer greater than $2$ and less than $n$ which does not divide $n-1$. Then, $2^{\left\lfloor\frac{n-1}{D}\right\rfloor} \not\equiv 1 \pmod{n}$.
\end{lemma}
\begin{proof}
We are given odd composite $n > 3$ with $2^{n-1} \equiv 1 \pmod{n}$. By the properties of the order of an integer modulo composite $n$, the smallest $k$ such that $2^k \equiv 1 \pmod{n}$, that is $k = \text{ord}_n(2)$, must be a divisor of $n-1$. Hence, $\text{ord}_n(2) \mid n-1$. Since $\left\lfloor\frac{n-1}{D}\right\rfloor$ is strictly less than $n-1$ and $D$ does not divide $n-1$, it follows that $2^{\left\lfloor\frac{n-1}{D}\right\rfloor} \not\equiv 1 \pmod{n}$.
\end{proof}

\subsection{Proof of the Main Theorem}
\begin{proof}[Proof of Theorem \ref{theorem:1}]
Let \( n \) be an odd integer $>3$ satisfying $2^{n-1} \equiv 1 \pmod{n}$.

Define \( f(x) = 2^{\left\lfloor \frac{x-1}{D} \right\rfloor} \) and \( D \) as the least integer greater than \( 2 \) that does not divide \( n-1 \). We begin with the congruence:
\begin{align}
(1 + f(n))^n \equiv \sum_{k=0}^{n} \binom{n}{k} f(k+1) \pmod{n}
\end{align}

Using the binomial theorem, we expand the left-hand side:
\begin{align}
\sum_{k=0}^{n} \binom{n}{k} f(n)^k \equiv \sum_{k=0}^{n} \binom{n}{k} f(k+1) \pmod{n}
\end{align}

Rewriting this, we must have:
\begin{align}
\sum_{k=0}^{n} \binom{n}{k} \left(f(n)^k - f(k+1)\right) \equiv 0 \pmod{n}.
\end{align}

As a necessary condition of our test, we also require:
\begin{align}
      \sum_{k=0}^{n} \binom{n}{k} f(n)^k \equiv \sum_{k=0}^{n} \binom{n}{k} f(k+1) \equiv 1 + f(n) \pmod{n}
\end{align}

By the binomial theorem, we isolate the inner terms:
\begin{align}
      1 + f(n)^n + \sum_{k=1}^{n-1} \binom{n}{k} f(n)^k \equiv 1 + f(n) + \sum_{k=1}^{n-1} \binom{n}{k} f(k+1) \equiv 1 + f(n) \pmod{n}
\end{align}

Setting common terms to zero:
\begin{align} \label{equation:congruence1}
      \sum_{k=1}^{n-1} \binom{n}{k} f(n)^k \equiv \sum_{k=1}^{n-1} \binom{n}{k} f(k+1) \equiv 0 \pmod{n}
\end{align}

We have defined $n$ such that $2^{n-1} \equiv 1 \pmod{n}$, which implies $\sum_{k=1}^{n-1} \binom{n}{k} \equiv 0 \pmod{n}$. Plugging it in:
\begin{align}
      \sum_{k=1}^{n-1} \binom{n}{k} \equiv \sum_{k=1}^{n-1} \binom{n}{k} f(n)^k \equiv \sum_{k=1}^{n-1} \binom{n}{k} f(k+1) \equiv 0 \pmod{n}
\end{align}

Subtracting $\sum_{k=1}^{n-1} \binom{n}{k}$ gives:
\begin{align}
\left(\sum_{k=1}^{n-1} \binom{n}{k} f(n)^k\right) - \sum_{k=1}^{n-1} \binom{n}{k} \equiv \left(\sum_{k=1}^{n-1} \binom{n}{k} f(k+1)\right) - \sum_{k=1}^{n-1} \binom{n}{k} \equiv 0 \pmod{n}
\end{align}

Combining the summations:
\begin{align}
\sum_{k=1}^{n-1} \left(\binom{n}{k} f(n)^k - \binom{n}{k}\right) \equiv \sum_{k=1}^{n-1} \left(\binom{n}{k} f(k+1) - \binom{n}{k}\right) \equiv 0 \pmod{n} \\
\sum_{k=1}^{n-1} \left(\binom{n}{k} f(n)^k - \binom{n}{k} f(k+1) - \binom{n}{k}\right) \equiv 0 \pmod{n}
\end{align}

Factoring out the common $\binom{n}{k}$ from the inner terms gives:
\begin{align}
\sum_{k=1}^{n-1} \binom{n}{k} \left(f(n)^k - f(k+1) - 1\right) \equiv 0 \pmod{n}
\end{align}

Looking back at \cref{equation:congruence1}, we must also have:
\begin{align}
    \sum_{k=1}^{n-1} \binom{n}{k} f(n)^k \equiv \sum_{k=1}^{n-1} \binom{n}{k} f(k+1) \equiv 0 \pmod{n} \\
    \sum_{k=1}^{n-1} \binom{n}{k} \left(f(n)^k - f(k+1)\right) \equiv 0 \pmod{n}
\end{align}

Which implies:
\begin{align}
\sum_{k=1}^{n-1} \binom{n}{k} \left(f(n)^k - f(k+1) - 1\right) \equiv \sum_{k=1}^{n-1} \binom{n}{k} \left(f(n)^k - f(k+1)\right) \equiv 0 \pmod{n}
\end{align}

For the above congruence, there are three potential cases we must examine.

\item \textbf{Case 1:} $n$ is prime
    
In this case, the congruence always holds. By the binomial theorem, $\binom{n}{k} \equiv 0 \pmod{n}$ for $0 < k < n$ and the congruence simplifies trivially to zero.

\item \textbf{Case 2:} $n$ is composite with $f(n) \equiv 1 \pmod{n}$

In this case, the congruence may or may not hold. With $f(n) \equiv 1 \pmod{n}$, the congruence simplifies significantly, making it possible:
\begin{align}
    \sum_{k=1}^{n-1} \binom{n}{k} f(k+1) \equiv \sum_{k=1}^{n-1} \binom{n}{k} \left(1 - f(k+1)\right) \equiv 0 \pmod{n} \\
    \sum_{k=1}^{n-1} \binom{n}{k} f(k+1) \equiv \sum_{k=1}^{n-1} \left(\binom{n}{k} - \binom{n}{k} f(k+1)\right) \equiv 0 \pmod{n} \\
    \sum_{k=1}^{n-1} \binom{n}{k} f(k+1) \equiv \sum_{k=1}^{n-1} \binom{n}{k} - \sum_{k=1}^{n-1} \binom{n}{k} f(k+1) \equiv 0 \pmod{n} \\
    \sum_{k=1}^{n-1} \binom{n}{k} f(k+1) \equiv \sum_{k=1}^{n-1} \binom{n}{k} f(k+1) \equiv 0 \pmod{n} \\
    \sum_{k=1}^{n-1} \binom{n}{k} f(k+1) \equiv 0 \pmod{n}
\end{align}

\item \textbf{Case 3:} $n$ is composite with $f(n) \not\equiv 1 \pmod{n}$

In this case, the congruence cannot hold. 

Since $\sum_{k=1}^{n-1} \binom{n}{k} \equiv 0 \pmod{n}$, we may add or subtract $\sum_{k=1}^{n-1} \binom{n}{k}$ from our congruence an arbitrary number of times and $n$ must still divide the sum. That means we must have:
\begin{align}
\sum_{k=1}^{n-1} \binom{n}{k} \left(f(n)^k - f(k+1) - X\right) \equiv \sum_{k=1}^{n-1} \binom{n}{k} \left(f(n)^k - f(k+1)\right) \equiv 0 \pmod{n}, \text{for all } X \in \mathbb{Z}.
\end{align}

For composite $n$, there is at least one $k$ such that $\binom{n}{k} \not\equiv 0 \pmod{n}$. Therefore, if $X$ can be any value, then so to can our sum:
\begin{align}
\sum_{k=1}^{n-1} \binom{n}{k} \left(f(n)^k - f(k+1) - X\right)
\end{align}

Hence, in order for our congruence to hold, all integers must be equivalent to $0 \pmod{n}$. Since $n\not=1$, this is impossible.

\textbf{Conclusion:}

When $n$ is an odd prime integer $>3$, the congruence holds. When $n$ is an odd composite integer $>3$, by Lemma \ref{lemma:1} we have $f(n) \not\equiv 1 \pmod{n}$ and therefore, the congruence cannot hold. Hence, the theorem is proven.

This completes the proof.
\end{proof}

\section{Algorithm}
\textbf{INPUT}: An integer $n > 1$.
\begin{center}
    \begin{enumerate}
        \item If $n \equiv 0 \mod{2}$:
            \begin{enumerate}
                \item If $n$ equals $2$, output PRIME.
                \item Otherwise, output COMPOSITE.
            \end{enumerate}
        \item If $n$ equals $3$, output PRIME.
        \item If $2^{n-1} \not\equiv 1 \pmod{n}$, output COMPOSITE.
        \item Find the least integer $D$ that is greater than 2 and less than $n$ which does not divide $n-1$.
        \item Set $A = 2^{\left\lfloor \frac{n-1}{D} \right\rfloor} \bmod{n}$.
        \item Set $B = (1 + A)^n \bmod{n}$.
        \item If $B \not\equiv 1 + A \pmod{n}$, output COMPOSITE.
        \item Set $C = \sum_{k=0}^{n} \binom{n}{k} 2^{\left\lfloor \frac{k}{D} \right\rfloor} \bmod{n}$.
        \item If $C \not\equiv 1 + A \pmod{n}$, output COMPOSITE.
        \item Output PRIME;
    \end{enumerate}
\end{center}

\subsection{Time Complexity Analysis}

\subsubsection{Algorithm Overview}
The given algorithm is a primality test that involves several computational steps, including modular arithmetic and polynomial exponentiation in the ring \(\mathbb{Z}/n\mathbb{Z}\).

\subsubsection{Analysis of Individual Operations}
\begin{enumerate}
    \item \textbf{Check for Even \( n \)}:
    
        This step involves calculating $n \bmod{2}$ and has a time complexity of \( O(1) \).

    \item \textbf{Modular Exponentiation \( 2^{n-1} \mod n \)}:
    
        This step requires modular exponentiation with a \( \log(n) \)-digit base and a \( \log(n) \)-digit exponent. The time complexity of modular exponentiation is \( O(\log(n) M(n)) \).

    \item \textbf{Finding \( D \)}:
    
        Finding the least integer \( D > 2 \) that does not divide \( n-1 \) takes at most \( O(\log(n)) \) steps, with each step requiring \( O(1) \) time for the mod operation. Hence, the overall complexity is \( O(\log(n)) \).

    \item \textbf{Computing \( A \) and \( B \)}:
    
        Each of these steps involves modular exponentiation similar to Step 2, and thus each has a time complexity of \( O(\log(n) M(n)) \).

    \item \textbf{Computing \( C \)}:
    
        Computing \( C \) involves exponentiating a polynomial in the ring \(\mathbb{Z}/n\mathbb{Z}\) with \( O(\log(n)) \) terms and summing the coefficients.
        \begin{enumerate}
            \item Summing the polynomial coefficients can be done in \( O(\log(n)^2) \) time.
            \item Exponentiation using repeated squaring takes \( O(\log(n)) \) steps, and each step requires \( O(M(n)\log(n)) \) time due to the multiplication of polynomials of size \( O(\log(n)) \).
        \end{enumerate}
         Therefore, the overall complexity for computing \( C \) is \( O(\log(n)^2 M(n)) \).

    \item \textbf{Comparisons}:
    
        The final steps involve comparisons which are \( O(1) \) operations.
\end{enumerate}

\subsubsection{Overall Time Complexity}
The dominant time complexity in the algorithm comes from computing \( C \). Therefore, the overall time complexity of the algorithm is \( T(n) = O(\log(n)^2 M(n)) \).

Harvey and van Der Heoven (2021) have given an algorithm for integer multiplication which has a time complexity $M(n) = O(\log(n) \log\log(n))$ \cite{harveyvanderhoeven2021}. This would give our algorithm an overall time complexity of:
\begin{align}
    T(n) = O(\log(n)^2 M(n)) = O(\log(n)^2 \log(n) \log\log(n)) = O(\log(n)^3 \log\log(n))
\end{align}

\subsubsection{Conclusion}
The overall complexity is polynomial in the size of \( n \) when expressed in terms of bit operations, making the algorithm efficient for large values of \( n \).

\subsection{Psuedocode Implementation}
To demonstrate how our test may be implemented, we offer a pseudocode implementation of the key functions involved.

\subsubsection{IsPrime Function}

\begin{algorithmic}
\Require An integer $n > 1$
\Function{IsPrime}{$n$}
    \If{$n \bmod 2 = 0$}
        \If{$n = 2$}
            \State \Return \textbf{true} \Comment{$n$ is prime}
        \Else
            \State \Return \textbf{false} \Comment{$n$ is composite}
        \EndIf
    \EndIf
    \If{$n = 3$}
        \State \Return \textbf{true} \Comment{$n$ is prime}
    \EndIf
    \State $fermat \gets \Call{Pow}{2, n-1, n}$ \Comment{Fermat pseudoprime test to base 2}
    \If{$fermat \neq 1$}
        \State \Return \textbf{false} \Comment{$n$ is composite}
    \EndIf
    \State $D \gets 2$
    \State $log \gets \Call{Log2}{n}$
    \For{$i \gets 3$ \textbf{to} $\Call{Max}{log, 3}$}
        \State $D \gets i$
        \State $m \gets (n-1) \bmod D$
        \If{$m \neq 0$}
            \State \textbf{break}
        \EndIf
    \EndFor
    \State $A \gets \Call{Pow}{2, \lfloor (n-1) / D \rfloor, n}$
    \State $expectedValue \gets (A + 1) \bmod n$
    \State $B \gets \Call{Pow}{A + 1, n, n}$
    \If{$B \neq expectedValue$}
        \State \Return \textbf{false} \Comment{$n$ is composite}
    \EndIf
    \State $polyDegree \gets D - 1$ \Comment{Subtract 1 to account for zero indexing in arrays}
    \State $poly \gets \Call{PolyPow}{[1, 1], n, n, polyDegree, [2]}$
    \State $C \gets \Call{PolyEval}{poly, 1} \bmod n$ \Comment{Evaluate at x=1 to sum coefficients}
    \If{$C \neq expectedValue$}
        \State \Return \textbf{false} \Comment{$n$ is composite}
    \EndIf
    \State \Return \textbf{true} \Comment{$n$ is prime}
\EndFunction
\end{algorithmic}

\subsubsection{PolyPow Function}
\begin{algorithmic}
\Function{PolyPow}{$poly_A$, $k$, $n$, $d$, $polyMapping$}
    \State $polyB \gets [1]$ \Comment{Initialize polyB as a polynomial with constant term 1}
    \While{$k > 0$}
        \If{$k \bmod 2 = 1$}
            \State $polyB \gets \Call{PolyMul}{polyA, polyB, n}$ \Comment{Multiply polynomials modulo $n$}
            \State $polyB \gets \Call{PolyReduce}{polyB, d, polyMapping, n}$ \Comment{Reduce degree of polyB}
            \If{$k = 1$}
                \State \textbf{break}
            \EndIf
        \EndIf
        \State $polyA \gets \Call{PolyMul}{polyA, polyA, n}$ \Comment{Square polyA modulo $n$}
        \State $polyA \gets \Call{PolyReduce}{polyA, d, polyMapping, n}$ \Comment{Reduce degree of polyA}
        \State $k \gets k / 2$
    \EndWhile
    \State \Return $polyB$
\EndFunction
\end{algorithmic}

\subsubsection{PolyReduce Function}
\begin{algorithmic}
\Function{PolyReduce}{$polyA$, $d$, $mappingPoly$, $n$}
    \If{$\Call{Length}{polyA} \leq d$}
        \State \Return $polyA$
    \EndIf

    \State $polyB \gets \Call{Clone}{polyA}$ \Comment{Copy the polynomial to a new array}
    \State $polyDegree \gets \Call{Degree}{mappingPoly}$ \Comment{Find degree of the mapping polynomial}
    \State $degreeDelta \gets d - polyDegree$

    \For{$i \gets \Call{Length}{polyB} - 1$ \textbf{downto} $d + 1$}
        \If{$polyB[i] = 0$}
            \State \textbf{continue}
        \EndIf
        \For{$j \gets i - 1 - degreeDelta$, $k \gets polyDegree$ \textbf{downto} $0$}
            \State $polyB[j] \gets polyB[j] + polyB[i] \times mappingPoly[k]$ \Comment{Degree reduction step}
        \EndFor
        \State $polyB[i] \gets 0$
    \EndFor

    \State $polyC \gets \text{new array of size } d + 1$
    \For{$i \gets 0$ \textbf{to} $\min(\Call{Length}{polyC}, \Call{Length}{polyB}) - 1$}  \Comment{Take coefficients modulo $n$}
        \State $polyC[i] \gets polyB[i]$
        \If{$n \neq 0$}
            \State $polyC[i] \gets polyC[i] \bmod n$
        \EndIf
    \EndFor

    \State \Return $polyC$
\EndFunction
\end{algorithmic}

\begingroup
\raggedright
\bibliographystyle{unsrtnat}
\bibliography{main}
\endgroup

\end{document}