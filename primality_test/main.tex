\pdfoutput=1
\documentclass{article}
\usepackage{fullpage}
\usepackage{amsmath, amssymb, amsthm}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[numbers]{natbib}
\usepackage{csquotes}
\usepackage{url}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{algorithmicx}
\setlength{\parskip}{0.5em}
\setlength{\parindent}{0pt}
\theoremstyle{plain}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{identity}{Identity}
\newtheorem{conjecture}{Conjecture}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{example}{Example}
\usepackage{graphicx}
\usepackage{multicol}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\totient}[1]{\phi\left({#1}\right)}
\newcommand{\bigO}[1]{O(#1)}
\newcommand{\softO}[1]{\tilde{O}(#1)}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\Zn}{\Z/n}
\newcommand{\Zx}{\Z[x]}
\newcommand{\Znx}{(\Zn)[x]}
\newcommand{\Rx}{R}
\newcommand{\Mx}{(\Zn)[x]/(x^d-2)}
\newcommand{\ord}[2]{\text{ord}_\text{#1}\left((#2)\right)}
\newcommand{\dtotient}[3]{\sigma_{#1}( #2^{\floor{\frac{1}{#3}}} )}
\newcommand{\ordn}[1]{\text{ord}_n\left({#1}\right)}
\newcommand{\indicator}[2]{\substack{#1 \\ #2}}
\newcommand{\glaisher}[2]{\left[ \begin{array}{c} #1 \\ #2 \end{array} \right]}
\newcommand{\kronecker}[2]{\left(#1\mid#2\right)}

\title{An Efficient Deterministic Primality Test}
\author{Joseph M. Shunia}
\date{December 2023}

\begin{document}

\maketitle

\begin{abstract}
A deterministic primality test with a polynomial time complexity of $\tilde{O}(\log^3(n))$ is presented. The test posits that an integer $n$ satisfying the conditions of the main theorem is prime. Combining elements of number theory and combinatorics, the proof operates on the basis of simultaneous modular congruences relating to binomial transforms of powers of two.
\end{abstract}

\section{Introduction}

Primality testing has seen remarkable advancements over the past few decades. A significant breakthrough in this field was the AKS primality test, introduced by Agrawal, Kayal, and Saxena (2002) \cite{aks2002}. The AKS test was the first to offer determinism and polynomial-time complexity, a monumental achievement that resolved a longstanding open question in computational number theory \cite{goldreich2008}. However, despite its theoretical importance, the AKS test has practical limitations due to its relatively high polynomial time complexity, rendering it inefficient for most applications. Agrawal, Kayal, and Saxena gave a time complexity of $\tilde{O}(\log^{12}(n))$ for the AKS test \cite{aks2002}. This bound was lowered significantly by Lenstra and Pomerance (2011) to $\tilde{O}(\log^6(n))$ \cite{lenstra2011}. Despite this reduction, AKS remains impractical and is mostly unused.

In the field of cryptography, the unique properties of prime numbers are widely exploited to create cryptographic primitives. It is often the case that many large primes must be generated in rapid succession \cite{lenstra1987}. To make these cryptographic operations practical, fast probabilistic primality tests such as the Baille-PSW primality test (BPSW) \cite{baillie1980} or Miller-Rabin (MR) \cite{rabin1980} \cite{miller1976} are used instead of AKS when searching for large primes. Probabilistic primality tests are by definition non-deterministic and may erroneously report a composite integer as being prime. Composite integers which pass a probabilistic primality test are relatively rare and are known as pseudoprimes (PSPs) for the respective test \cite{wagstaff1983}. When generating primes for cryptographic purposes, probabilistic primality tests are often combined or repeated with different parameters in order to achieve an acceptable error-bound that makes it almost certain that no composite integer will pass. However, reducing the error-bound requires additional compute and increases running-time, creating a trade-off.

We present a new deterministic primality test that operates in polynomial time with a time complexity of $\tilde{O}(\log^3(n))$. This efficiency gain opens new avenues for practical applications, particularly in cryptography, where fast and reliable primality testing is desirable \cite{pomerance1984}. 

Our test is based on a famous conjecture issued by Manindra Argawal while he was an undergraduate student \cite{aks2002}. Let $n$ and $d$ be two coprime positive integers. If the following polynomial congruence holds, then $n$ is prime or $n^2 = 1 \pmod{d}$:
\begin{align}
    (x - 1)^n \equiv x^n - 1 \pmod{n, x^d - 1}
\end{align}

We alter the conditions slightly to use roots of $2$ instead of roots of unity. Through the proof of our main theorem, we demonstrate that our modified test is equivalent to checking the polynomial congruence $(1 + x)^n \equiv 1 + x^n \pmod{n}$, a congruence which is known to hold for only prime integers $n$ \cite{granville2004primes}.

\subsection{Structure of the Paper}
This paper is structured as follows: We begin by presenting the main theorem which defines our primality test. We follow up with supporting theorems, identities, and lemmas. Then, we present the proof of our main theorem. The proof of our main theorem demonstrates the test's validity for odd prime numbers and its failure for odd composite numbers. Through this, we establish the deterministic nature of our test. We then describe the algorithm used to compute our test and analyze its computational complexity. We conclude with pseudocode for our test, and a link to an open source implementation, to demonstrate how our test can be implemented.

\section{Statement of Main Theorem}
\begin{theorem}[Main theorem]
\label{theorem:main}
Let $n$ be an odd integer $> 3$ such that $2^{n-1} \equiv 1 \pmod{n}$. Denote $d$ as the least integer greater than $2$ such that $n \not\equiv 1 \pmod{d}$. If the following polynomial congruence holds, then either $n$ is prime or $n$ has a prime divisor $p \leq d$:
\begin{align}
    (1 + x)^n \equiv 1 + x^n \pmod{n, x^d - 2}
\end{align}
\end{theorem}

\section{Supporting Identities}

\begin{identity}[Powers of two] \label{identity:powersoftwobinomialgroups}
Let $n, d \in \Z^+$, with $1 \leq d < n$:
\begin{align}
    2^n = \sum_{j=0}^{d-1} \sum_{k=0}^{n} \binom{n}{kd + j}
\end{align}
\end{identity}
\begin{proof}
    By the binomial theorem, $2^n = \sum_{k=0}^{n} \binom{n}{k}$. We can split this sum up into $d$ groups of at most $\floor{\frac{n}{d}}$ terms, like so:
    \begin{align}
        2^n = \sum_{k=0}^{n} \binom{n}{k} = \sum_{j=0}^{d-1} \sum_{k=0}^{\floor{\frac{n}{d}}} \binom{n}{kd + j}
    \end{align}

    For $k > \floor{\frac{n}{d}}$, we have $d k + j > n$. In such case, $\binom{n}{d k + j} = 0$. Hence, we can say:
    \begin{align}
        \sum_{j=0}^{d-1} \sum_{k=0}^{\floor{\frac{n}{d}}} \binom{n}{kd + j} = \sum_{j=0}^{d-1} \sum_{k=0}^{n} \binom{n}{kd + j}
    \end{align}
\end{proof}

\begin{identity}[Binomial transform of floored powers of two] \label{identity:flooredpowersoftwobinomialgroups}
Let $n, d \in \Z^+$, with $1 \leq d < n$:
\begin{align}
    \sum_{k=0}^{n} \binom{n}{k} 2^{\floor{\frac{k}{d}}} = \sum_{j=0}^{d-1} \sum_{k=0}^{n} \binom{n}{kd + j} 2^{k}
\end{align}
\end{identity}
\begin{proof}
    By Identity \ref{identity:powersoftwobinomialgroups}, we have:
    \begin{align}
        \sum_{k=0}^{n} \binom{n}{k} = \sum_{j=0}^{d-1} \sum_{k=0}^{\floor{\frac{n}{d}}} \binom{n}{kd + j}
    \end{align}

    Applying this to $\sum_{k=0}^{n} \binom{n}{k} 2^{\floor{\frac{k}{d}}}$, since the exponent in $2^{\floor{\frac{k}{d}}}$ is partitioned by $d$, it splits over the groups. We may rewrite our equation as:
    \begin{align}
        \sum_{k=0}^{n} \binom{n}{k} 2^{\floor{\frac{k}{d}}} = \sum_{j=0}^{d-1} \sum_{k=0}^{\floor{\frac{n}{d}}} \binom{n}{kd + j} 2^{k}
    \end{align}

    As in Identity \ref{identity:powersoftwobinomialgroups}, for $k > \floor{\frac{n}{d}}$, we have $d k + j > n$. In such case, $\binom{n}{kd + j} = 0$. Hence, we can say:
    \begin{align}
        \sum_{j=0}^{d-1} \sum_{k=0}^{\floor{\frac{n}{d}}} \binom{n}{kd + j} 2^{k} = \sum_{j=0}^{d-1} \sum_{k=0}^{n} \binom{n}{kd + j} 2^{k}
    \end{align}
\end{proof}

\section{Polynomial Ring Theorems}

\begin{theorem} \label{theorem:polyflooredpowersoftwo}
Let $n, d \in \Z^+$ with $d>2$. Let $x^k$ be a polynomial in $(\Zn)[x]/(x^d-2)$. Taking the sum of the coefficients modulo $n$ in the polynomial expansion of \( x^k \), gives $2^{\floor{\frac{k}{d}}} \pmod{n}$.
\end{theorem}
\begin{proof}
Examining $d = 2$, we can see:
\begin{align*}
& x^0 = 1 = 2^{\floor{0/2}} \\
& x^1 = 1 = 2^{\floor{1/2}} \\
& x^2 = 2 = 2^{\floor{2/2}}\\
& x^3 = 2x = 2 = 2^{\floor{3/2}}\\
& x^4 = 2x^2 = 4 = 2^{\floor{4/2}}\\
& x^5 = 4x = 4 = 2^{\floor{5/2}}\\
& x^6 = 4x^2 = 8 = 2^{\floor{6/2}}\\
\vdots
\end{align*}

We proceed by induction. For \( k = 0 \), we have \( x^0 = 1 \), and the sum of coefficients is \( 2^{\floor{\frac{0-1}{d}}} = 2^{0} = 1 \). Assume the theorem holds for some \( k \geq 0 \), that is, the sum of coefficients modulo \( n \) in \( x^k \) is \( 2^{\floor{\frac{k}{d}}} \pmod{n} \). We need to show it also holds for \( k+1 \). Consider \( x^{k+1} = x^k \cdot x \). By the definition of the ideal $I = x^d-2$, the degree of \( x^{k+1} \) gets reduced every time it reaches \( d \). The number of times this reduction happens is \( \floor{\frac{k}{d}} \). Therefore, the sum of coefficients in \( x^{k+1} \) should be \( 2^{\floor{\frac{k+1}{d}}} \), as each reduction doubles the sum of coefficients. Hence, the theorem holds for \( k+1 \). By the principle of mathematical induction, the theorem is proven.
\end{proof}

\begin{theorem} \label{theorem:polybinomialtransform}
Let $n$ an integer $>0$. Let $d$ be an integer $>2$. Let $(1 + x)^n$ be a polynomial in $(\Zn)[x]/(x^d-2)$. Taking the sum of the coefficients modulo $n$ in the polynomial expansion of $ (1 + x)^n$ is equivalent to $\sum_{k=0}^{n} \binom{n}{k} 2^{\floor{\frac{k}{d}}} \pmod{n}$.
\end{theorem}
\begin{proof}
By the binomial theorem, we have:
\begin{align}
    (1 + x)^n = \sum_{k=0}^{n} \binom{n}{k} x^{k}
\end{align}
Hence, when we evaluate this polynomial at \( x = 1 \), we sum the coefficients of the polynomial to get:
\begin{align}
    \sum_{k=0}^{n} \binom{n}{k} 2^{\floor{\frac{k}{d}}} \quad \text{(by Theorem \ref{theorem:polyflooredpowersoftwo})}
\end{align}
\end{proof}

\section{Supporting Lemmas}
\begin{lemma} \label{lemma:floornondivisor}
Given $a,b \in \Z^{+}$ with \(b \nmid a\) and \( 1 < b < \left\lfloor \frac{a}{b} \right\rfloor \), then \(\left\lfloor \frac{a}{b} \right\rfloor \) cannot divide \(a\).
\end{lemma}
\begin{proof}
Let \(q = \left\lfloor \frac{a}{b} \right\rfloor\). By definition, \(q\) is the greatest integer that is less than \(\frac{a}{b}\). Thus, \(q \cdot b < a < b \cdot (q + 1)\).

Suppose, for contradiction, that \(q\) divides \(a\). Then there exists an integer \(k\) such that \(a = k \cdot q\). Substituting \(a = k \cdot q\) into the inequality \(q \cdot b < a < b \cdot (q + 1) \), we get \(q \cdot b < k \cdot q < b \cdot (q + 1) \). Dividing this inequality by \(q\), we obtain \(b < k < b + \frac{b}{q}\).

Since \(k\) is an integer, and \(b \nmid a\) implies \(k \neq b\), the next possible integer value for \(k\) is \(b + 1\). Therefore, \(k = b + 1\), which gives \(a = k \cdot q = q \cdot (b + 1)\). However, this leads to a contradiction: \(a = q \cdot (b + 1) \) implies \(a \geq b \cdot (q + 1) \), contradicting the established fact that \(a < b \cdot (q + 1) \). Hence, our assumption that \(q\) divides \(a\) is false. Therefore, \(\left\lfloor \frac{a}{b} \right\rfloor \nmid a\).
\end{proof}

\begin{lemma}[Upper bound on floor function and indivisibility]
\label{lemma:floornondivisorupperbound}
Given $a,b \in \Z^{+}$ with \( 1 < b < \left\lfloor \frac{a}{b} \right\rfloor \), then \(b \leq \left\lfloor \sqrt{a} \right\rfloor\).
\end{lemma}
\begin{proof}
Assume \( a, b \in \Z^{+} \) and \( 1 < b < \left\lfloor \frac{a}{b} \right\rfloor \). By definition, \( \left\lfloor \frac{a}{b} \right\rfloor \) is the greatest integer less than or equal to \( \frac{a}{b} \). Hence, \( \left\lfloor \frac{a}{b} \right\rfloor \leq \frac{a}{b} \). Since \( b < \left\lfloor \frac{a}{b} \right\rfloor \), we have \( b^2 < b \cdot \left\lfloor \frac{a}{b} \right\rfloor \leq a \). Taking square roots on both sides of the inequality \( b^2 < a \) and considering that \( b \) and \( \sqrt{a} \) are both positive, we get \( b < \sqrt{a} \). Since \( b \) and \( \sqrt{a} \) are positive integers, and \( b < \sqrt{a} \), it follows that \( b \leq \left\lfloor \sqrt{a} \right\rfloor \).
\end{proof}

\begin{lemma}[Bounds on least non-divisor] \label{lemma:leastnondivisor}
Let $n$ be an integer such that $n > 3$, then there exists an integer $1 < D \leq \left\lfloor\log_2(n-1)\right\rfloor + 2$ which does not divide $n-1$.
\end{lemma}
\begin{proof}
If $n$ is a composite integer $> 3$, clearly $n-1$ can have at most $\left\lfloor\log_2(n-1)\right\rfloor$ prime factors (when $n-1$ is a power of $2$). Since $2$ is the least prime that may divide $n-1$, there must exist a $D \leq \left\lfloor\log_2(n-1)\right\rfloor + 2$ which does not divide $n-1$.
\end{proof}

\begin{lemma}[Multiplicative order inequality] \label{lemma:orderinequality}
Let \( n \) be an odd composite integer greater than 3 such that \( 2^{n-1} \equiv 1 \pmod{n} \). Denote by \( D \) the least integer \(2 < D < n \) which does not divide \( n-1 \). Then, \( \left\lfloor\frac{n-1}{D}\right\rfloor \not= \ordn{2} \).
\end{lemma}
\begin{proof}
Consider an odd composite integer \( n > 3 \) for which \( 2^{n-1} \equiv 1 \pmod{n} \). According to the properties of the multiplicative order modulo $n$, the smallest positive integer \( k \) such that \( 2^k \equiv 1 \pmod{n} \) defines \( \ordn{2} \), that is, \( k = \ordn{2} \). Since $n$ is composite and \( 2^{n-1} \equiv 1 \pmod{n} \), this order, \( \ordn{2} \), must divide \( n-1 \).

Given \( D \) is the least integer greater than 2 and less than \( n \) that does not divide \( n-1 \), and \( \ordn{2} \) divides \( n-1 \), it follows that \( D \) cannot equal \( \ordn{2} \). Furthermore, by Lemma \ref{lemma:floornondivisor}, we know that if an integer \( b \) does not divide an integer \( a \), and \( 1 < b < \left\lfloor \frac{a}{b} \right\rfloor \), then \( \left\lfloor \frac{a}{b} \right\rfloor \) does not divide \( a \). Applying this to our current context with \( a = n-1 \) and \( b = D \): The least odd composite integer such that \( 2^{n-1} \equiv 1 \pmod{n} \) is $341$ \cite{oeisfermatpspbase2}. It follows from Lemma \ref{lemma:leastnondivisor} that $D$ must be less than or equal to $\left\lfloor\log_2(n-1)\right\rfloor + 2$. For $n \geq 341$, clearly $D < \left\lfloor\sqrt{n}\right\rfloor$ which satisfies Lemma \ref{lemma:floornondivisorupperbound}. Thus we have \( 1 < D < \left\lfloor \frac{n-1}{D} \right\rfloor \) and hence, \( \left\lfloor \frac{n-1}{D} \right\rfloor \) cannot divide \( n-1 \).

Since \( \ordn{2} \) is a divisor of \( n-1 \) and \( \left\lfloor \frac{n-1}{D} \right\rfloor \) is not, it must be that \( \left\lfloor \frac{n-1}{D} \right\rfloor \) is not equal to \( \ordn{2} \), as this would imply a contradiction with the nature of \( \ordn{2} \) as a divisor of \( n-1 \). Therefore, \( \left\lfloor\frac{n-1}{D}\right\rfloor \not= \ordn{2} \).
\end{proof}

\begin{lemma} \label{lemma:polytermcoeffs}
Let $n, d \in \Z^+$, with $1 \leq d < n$. For $(1 + x)^n \in (\Zn)[x]/(x^d-2)$, we have:
\begin{align}
    [x^j](1 + x)^n \equiv \sum_{k=0}^{n} \binom{n}{d k + j} 2^{k} \pmod{n}
\end{align}
\end{lemma}
\begin{proof}
By Identity \ref{identity:flooredpowersoftwobinomialgroups}, we have $\sum_{k=0}^{n} \binom{n}{k} 2^{\floor{\frac{k}{d}}} = \sum_{j=0}^{d-1} \sum_{k=0}^{n} \binom{n}{d k + j} 2^{k}$. In Theorem \ref{theorem:polybinomialtransform}, we showed that evaluating $(1+x)^n \in M$ at $x=1$ yields $\sum_{k=0}^{n} \binom{n}{k} 2^{\floor{\frac{k}{d}}}$. Upon expansion $(1+x)^n$ will contain at most $d$ terms. By the nature of exponentiation within our ring, these groups are spaced uniformly over the binomial coefficients. That is, the coefficient of the term $x^j$ in the expanded polynomial corresponds to the sum $\sum_{k=0}^{n} \binom{n}{d k + j} 2^{k} \pmod{n}$.
\end{proof}

\begin{lemma}[Upper bound on $d$] \label{lemma:leastd}
Let $n$ be an integer such that $n > 3$, then there exists an integer $d$ such that $1 < d \leq \floor{\log_2(n-1)} + 2$ and $n \not\equiv 1 \pmod{d}$.
\end{lemma}
\begin{proof}
In order to have $n \equiv 1 \pmod{d}$ for some integer $d$, there must exist an integer $k$ such that $d \cdot k + 1 \equiv 0 \pmod{n}$. This implies that any such $d$ will divide $n-1$. Given $n$ is a composite integer $> 3$, clearly $n-1$ can have at most $\floor{\log_2(n-1)}$ prime factors (if $n-1$ is a power of $2$). Since $2$ is the least prime that may divide $n-1$, there must exist a $d \leq \floor{\log_2(n-1)} + 2$ which does not divide $n-1$. This implies $n-1 \not\equiv 0 \pmod{d}$ and hence it follows, $n \not\equiv 1 \pmod{d}$.
\end{proof}

\subsection{Primes Case}

\begin{lemma}[Primes pass] \label{lemma:primes}
Let $n$ be an odd prime integer such that $n > 3$. Denote $d$ as the least integer greater than $2$ such that $n \not\equiv 1 \pmod{d}$. Then, the conditions of Theorem \ref{theorem:main} hold unconditionally and $n$ will pass the test.
\end{lemma}
\begin{proof}
For this proof, we will examine all of the cases individually and show that they are satisfied for prime $n$.

\textbf{Case 1:} $j=0$ \\
If $j = 0$, then all $\binom{n}{d k} \equiv 0 \pmod{n}$ except for $k=0$. Hence, we have:
\begin{align}
    & \sum_{k=0}^{\floor{\frac{n}{d}}} \binom{n}{d k} 2^{k} \equiv \binom{n}{0} 2^{0} \equiv 1 \cdot 1 \equiv 1 \pmod{n}
\end{align}

\textbf{Case 2:} $0 < j < d$ and $j \neq n \bmod{d}$ \\
If $0 < j < d$ and $j \neq n \bmod{d}$, all $\binom{n}{d k + j} \equiv 0 \pmod{n}$. Hence, the entire sum $\sum_{k=0}^{\floor{\frac{n}{d}}} \binom{n}{d k + j} 2^{k}$ must be equivalent to $0 \pmod{n}$.

\textbf{Case 3:} $j=n \bmod{d}$ \\
If $j = n \bmod{d}$, then all $\binom{n}{d k} \equiv 0 \pmod{n}$ except for $k=\floor{\frac{n}{d}}$. Hence, we have:
\begin{align}
    & \sum_{k=0}^{\floor{\frac{n}{d}}} \binom{n}{d k + (n \bmod{d})} 2^{k} \equiv \binom{n}{n} 2^{\floor{\frac{n}{d}}} \equiv 1 \cdot 2^{\floor{\frac{n}{d}}} \equiv 2^{\floor{\frac{n}{d}}} \pmod{n}
\end{align}

\textbf{Conclusion:}
All of the individual conditions are satisfied when $n > 3$ is an odd prime. Hence, $n$ will pass the test unconditionally.
\end{proof}

\subsection{Composites Case}

A fundamental theorem in polynomial ring theory states that an integer $n$ is prime if and only if $(1 + x)^n \equiv 1 + x^n \pmod{n} \in \Z[x]$ \cite{granville2004primes}. This congruence was used as the basis for the AKS test \cite{aks2002}. A short proof of the theorem, given by Granville (2004) \cite{granville2004primes}, is that since $(x + 1)^n - (x^n + 1) = \sum_{k=1}^{n-1} \binom{n}{k} x^k$, we may have $(1 + x)^n \equiv 1 + x^n \pmod{n}$ if and only if $n$ divides $\binom{n}{k}$ for all $k$ in the range $1 \leq k \leq n-1$. It is important to note that for the polynomial congruence to be valid, $x^n$ and $(1+x)^n$ must be irreducible in $(\Zn)[x]$.

Kopparty and Wang (2014) \cite{koppartywang2014roots} proved several theorems related to limits on the counts of consecutive zero coefficients in polynomials over finite fields. We take a similar approach to show that composite integers will always fail our test.

\begin{lemma}[Composites fail] \label{lemma:composites}
Let $n = pq$ be an odd composite integer $>3$ with $p$ a prime divisor. Let $d$ be the least positive integer $>2$ such that $n \not\equiv 1 \pmod{d}$. Suppose $2^{\left\lfloor\frac{n}{d}\right\rfloor} \not\equiv 1 \pmod{n}$, and consider the polynomial $f(x) = (1 + x)^n - (1 + x^n) \in \mathbb{Z}_p[x]$. If $n$ does not have a prime divisor $\leq d$, then $f(x)$ is nonzero when reduced modulo $x^d - 2$.
\end{lemma}
\begin{proof}
Let $p$ be a prime divisor of $n$. Consider the polynomial ring $\mathbb{Z}_p[x]$. We examine the reduction of $ f(x) $ modulo $x^d - 2$, which gives us a polynomial $f(x) \pmod{x^d - 2} \in \mathbb{Z}_p[x]$. After reduction modulo $x^d - 2$, the polynomial $f(x)$ has $\deg(f(x)) = d-1$, and can be written as $f(x) = \sum_{i=0}^{d-1} c_i x^i$.

The condition $2^{\left\lfloor\frac{n}{d}\right\rfloor} = x^n \not\equiv 1 \pmod{n}$ implies that $2^{\left\lfloor\frac{n}{d}\right\rfloor} = x^n \not\equiv 1 \pmod{p}$ for at least $1$ prime divisor $p$ of $n$. Recall also that we are given $d$ which does not divide $n$, and hence $p \not= d$. Together, these imply that the powers $x^k$ in $f(x)$ do not behave in a cyclical manner when reduced modulo $p$, and hence, the polynomial $f(x)$ cannot simplify to the zero polynomial due to any cyclical patterns in the exponents. Furthermore, the fact that $x^d = 2$ in our quotient ring, and not $1$, ensures that $x$ is not a $d$th root of unity in $\mathbb{Z}_p$ for any prime $p$ dividing $n$. Hence, $f(x)$ does not exhibit any cyclical reduction that would occur if $x$ were a root of unity.

Assume for contradiction that $f(x)$ is the zero polynomial in $\mathbb{Z}_p[x]/(x^d - 2)$. This would imply that all coefficients $c_i$ are zero in $\mathbb{Z}_p$.

Since $p$ is prime, $\mathbb{Z}_p[x]$ is a finite field. Further, since $2^{\left\lfloor\frac{n}{d}\right\rfloor} \not\equiv 1 \pmod{n}$, there must exist at least $1$ prime divisor $p$ of $n$ such that $2^{\left\lfloor\frac{n}{d}\right\rfloor} \not\equiv 1 \pmod{p}$. This implies that $2$ is not a $d$th power residue modulo $p$. That is, $a^d \not\equiv 2 \pmod{p}$ for all integers $a$. Hence, it follows that $x^d - 2$ is irreducible over $\mathbb{Z}_p[x]$ and therefore, $\mathbb{Z}_p[x]/(x^d - 2)$ forms a field.

By the Fundamental Theorem of Algebra for finite fields, if $\mathbb{Z}_p[x]/(x^d - 2)$ is a field and $\deg(f(x)) = d-1$, then $f(x)$ can have at most $d-1$ roots in $\mathbb{Z}_p[x]/(x^d - 2)$. The assumption that $f(x)$ is zero would imply it has $p$ roots, which is a contradiction unless $p \leq d-1$. However, this is clearly false, since we are given $n$ which does not have a prime divisor $\leq d$.

Therefore, $f(x)$ must be nonzero in $\mathbb{Z}_p[x]/(x^d - 2)$ for at least one prime $p$ that divides $n$.
\end{proof}

\section{Proof of the Main Theorem}
\begin{proof}[Proof of Theorem \ref{theorem:main}]
Let \( n \) be an odd integer $>3$. If $n$ is prime, then by Lemma $\ref{lemma:primes}$, the congruences for our test hold and $n$ will pass the test. Conversely, if $n$ is composite, then by Lemma \ref{lemma:composites} the congruences for our test cannot hold and $n$ will fail the test. Hence, the theorem is proven.
\end{proof}

\section{Algorithm} \label{section:algorithm}
\textbf{INPUT}: An integer $n > 1$.
\begin{center}
    \begin{enumerate}
        \item If $n \equiv 0 \mod{2}$:
            \begin{enumerate}
                \item If $n$ equals $2$, output PRIME.
                \item Otherwise, output COMPOSITE.
            \end{enumerate}
        \item If $n$ equals $3$, output PRIME.
        \item Find the least integer $d$ that is greater than $2$ such that $n \not\equiv 1 \pmod{d}$.
        \item Compute the polynomial expansion of $x^n \bmod{n}$ in the ring $(\Zn)[x]/(x^d-2)$ with degree $d$, and store the result.
        \item Compute the polynomial expansion of $(1 + x)^n \bmod{n}$ in the ring $(\Zn)[x]/(x^d-2)$ with degree $d$, and store the result.
        \item If $(1 + x)^n \not= 1 + x^n$, output COMPOSITE.
        \item Output PRIME;
    \end{enumerate}
\end{center}

\subsection{Time Complexity Analysis} \label{subsection:timecomplexity}

\subsubsection{Algorithm Overview}
The given algorithm is a primality test that involves several computational steps, including modular arithmetic and polynomial exponentiation in the ring $\Mx$.

\subsubsection{Analysis of Individual Operations}
\begin{enumerate}
    \item \textbf{Check for Even \( n \)}:
    
        This step involves calculating $n \bmod{2}$ and has a time complexity of \( O(1) \).

    \item \textbf{Finding \( d \)}:
    
        Finding the least integer \( d > 2 \) such that $n \not\equiv 1 \pmod{d}$ takes at most \( O(\log(n)) \) steps, with each step requiring \( O(1) \) time for the mod operation. Hence, the overall complexity is \( O(\log(n)) \).

    \item \textbf{Computing \( x^n \bmod{n} \in \Mx \)}:
    
        Computing the polynomial expansion of $x^n \pmod{n}$ in the ring \( \Mx \) with degree $d$ is equivalent to calculating $2^{\floor{\frac{n}{d}}} \pmod{n}$. This step requires modular exponentiation with a \( \log(n) \)-digit base and a \( \log(n) \)-digit exponent. The time complexity of modular exponentiation is \( O(\log(n) M(n)) \).

    \item \textbf{Computing \( (1+x)^n \bmod{n} \in \Mx \)}:
    
        Computing the polynomial expansion of \( (1+x)^n \pmod{n} \) in the ring \( (\Zn)[x]/(x^d-2) \)  with degree $d$ involves exponentiating a polynomial in $(\Zn)[x]/(x^d-2)$ with \( D = O(\log(n)) \) terms. Exponentiation using repeated squaring takes \( O(\log(n)) \) steps, and each step requires \( O(M(n)\log(n)) \) time due to the multiplication of polynomials of size \( O(\log(n)) \). Therefore, the overall complexity is \( O(\log^2(n) m(n)) \).
         
    \item \textbf{Checking the equality \( (1+x)^n = 1 + x^n \pmod{n} \in (\Zn)[x]/(x^d-2) \)}:
        The final steps involve comparing the equality of coefficients in the polynomials $(1+x)^n$ and $1 + x^n$. This requires $O(\log(n))$ comparisons, which are themselves \( O(1) \) operations.
\end{enumerate}

\subsubsection{Overall Time Complexity}
The dominant time complexity in the algorithm comes from computing \( (1+x)^n \pmod{n} \in (\Zn)[x]/(x^d-2) \). Therefore, the overall time complexity of the algorithm is \( T(n) = O(\log^2(n) M(n)) \).

Harvey and van Der Heoven (2021) have given an algorithm for integer multiplication which has a time complexity $M(n) = O(\log(n) \log\log(n))$ \cite{harveyvanderhoeven2021}. This would give our algorithm an overall time complexity of:
\begin{align}
    T(n) = O(\log^2(n) M(n)) = O(\log^2(n) \log(n) \log\log(n)) = O(\log^3(n) \log\log(n)) = \tilde{O}(\log^3(n))
\end{align}

\subsubsection{Conclusion}
The overall complexity is polynomial in the size of \( n \) when expressed in terms of bit operations, making the algorithm efficient for large values of \( n \).

\section{Implementation Details}
\subsection{Reference Implementation}
Sample open source .NET and Python implementations, along with test data, are available on the author's Github page \cite{githubrepo}.

 \subsection{Pseudocode Implementation}
To demonstrate how our test may be implemented, we offer a pseudocode implementation of the key functions involved.

\subsubsection{IsPrime Function}

\begin{algorithmic}
\Require An integer $n > 1$
\Function{IsPrime}{$n$}
    \If{$n \bmod 2 = 0$}
        \If{$n = 2$}
            \State \Return \textbf{true} \Comment{$n$ is prime}
        \Else
            \State \Return \textbf{false} \Comment{$n$ is composite}
        \EndIf
    \EndIf
    \If{$n = 3$}
        \State \Return \textbf{true} \Comment{$n$ is prime}
    \EndIf
    \State $d \gets 2$
    \State $log \gets \Call{Log2}{n}$
    \For{$i \gets 3$ \textbf{to} $\Call{Max}{log+2, 3}$} \Comment{Find $d$, the least non-divisor of $n-1$}
        \State $d \gets i$
        \State $m \gets (n-1) \bmod d$
        \If{$m \neq 0$}
            \State \textbf{break}
        \EndIf
    \EndFor
    \State $v_x \gets \Call{Pow}{2, \floor{n / d}, n}$
    \State $polyDegree \gets d - 1$ \Comment{Subtract 1 to account for zero indexing in polynomials}
    \State $poly \gets \Call{PolyPow}{[1, 1], n, n, polyDegree, [2]}$
    \If{$poly[0] \neq 1$}
        \State \Return \textbf{false} \Comment{$n$ is composite}
    \EndIf
    \State $x_\text{index} \gets n \bmod{d}$
    \For{$i \gets 1$ \textbf{to} $d$} \Comment{Check polynomial equality}
        \If{$i = x_\text{index}$}
            \If{$poly[i] \neq v_x$}
                \State \Return \textbf{false} \Comment{$n$ is composite}
            \EndIf
        \Else
            \If{$poly[i] \neq 0$}
                \State \Return \textbf{false} \Comment{$n$ is composite}
            \EndIf
        \EndIf
    \EndFor
    \State \Return \textbf{true} \Comment{$n$ is prime}
\EndFunction
\end{algorithmic}

\subsubsection{PolyPow Function}
\begin{algorithmic}
\Function{PolyPow}{$poly_A$, $k$, $n$, $d$, $polyMapping$}
    \State $polyB \gets [1]$ \Comment{Initialize polyB as a polynomial with constant term 1}
    \While{$k > 0$}
        \If{$k \bmod 2 = 1$}
            \State $polyB \gets \Call{PolyMul}{polyA, polyB, n}$ \Comment{Multiply polynomials modulo $n$}
            \State $polyB \gets \Call{PolyReduce}{polyB, d, polyMapping, n}$ \Comment{Reduce degree of polyB}
            \If{$k = 1$}
                \State \textbf{break}
            \EndIf
        \EndIf
        \State $polyA \gets \Call{PolyMul}{polyA, polyA, n}$ \Comment{Square polyA modulo $n$}
        \State $polyA \gets \Call{PolyReduce}{polyA, d, polyMapping, n}$ \Comment{Reduce degree of polyA}
        \State $k \gets k / 2$
    \EndWhile
    \State \Return $polyB$
\EndFunction
\end{algorithmic}

\subsubsection{PolyReduce Function}
\begin{algorithmic}
\Function{PolyReduce}{$polyA$, $d$, $mappingPoly$, $n$}
    \If{$\Call{Length}{polyA} \leq d$}
        \State \Return $polyA$
    \EndIf

    \State $polyB \gets \Call{Clone}{polyA}$ \Comment{Copy the polynomial to a new array}
    \State $polyDegree \gets \Call{Degree}{mappingPoly}$ \Comment{Find degree of the mapping polynomial}
    \State $degreeDelta \gets d - polyDegree$

    \For{$i \gets \Call{Length}{polyB} - 1$ \textbf{downto} $d + 1$}
        \If{$polyB[i] = 0$}
            \State \textbf{continue}
        \EndIf
        \For{$j \gets i - 1 - degreeDelta$, $k \gets polyDegree$ \textbf{downto} $0$}
            \State $polyB[j] \gets polyB[j] + polyB[i] \times mappingPoly[k]$ \Comment{Degree reduction step}
        \EndFor
        \State $polyB[i] \gets 0$
    \EndFor

    \State $polyC \gets \text{new array of size } d + 1$
    \For{$i \gets 0$ \textbf{to} $\min(\Call{Length}{polyC}, \Call{Length}{polyB}) - 1$}  \Comment{Take coefficients modulo $n$}
        \State $polyC[i] \gets polyB[i]$
        \If{$n \neq 0$}
            \State $polyC[i] \gets polyC[i] \bmod n$
        \EndIf
    \EndFor

    \State \Return $polyC$
\EndFunction
\end{algorithmic}

\section{Acknowledgements}
The author would like to thank the kind users at \url{mersenneforum.org} for their helpful feedback.

\begingroup
\raggedright
\bibliographystyle{unsrtnat}
\bibliography{main}
\endgroup

\end{document}